#!/usr/bin/env bash

check_dependencies() {
    local missing_dependencies=()

    # Check for each dependency
    for dep in "$@"; do
        if ! type "$dep" &>/dev/null; then
            missing_dependencies+=("$dep")
        fi
    done

    # If there are missing dependencies, print them and exit
    if [ ${#missing_dependencies[@]} -ne 0 ]; then
        echo >&2 "Missing dependencies: ${missing_dependencies[@]}"
        exit 1
    fi
}

read_sleep() {
    # Usage: read_sleep 1
    #        read_sleep 0.2
    read -rt "$1" <> <(:) || :
}

build_sed_replace_command() {
    local sed_command=""
    for key in "${!CFG_REPLACE_MAP[@]}"; do
        local value="${CFG_REPLACE_MAP[$key]}"
        sed_command+="s/$key/$value/g;"
    done

    echo "$sed_command"
}

is_array() {
    local var_name=$1
    local var_decl
    var_decl=$(eval "declare -p $var_name" 2>/dev/null)
    [[ $var_decl =~ "declare -a" ]]
}

# Function to extract the value of a given parameter
extract_param_value() {
    local param_name="$1"
    shift
    local params=("$@")
    local param_value=""

    for (( i=0; i<${#params[@]}; i++ )); do
        if [[ "${params[i]}" == "$param_name" ]]; then
            # Assuming the next item is the value
            param_value="${params[i+1]}"
            break
        fi
    done

    echo "$param_value"
}

DEFAULT_STACK_COLORS=("#ff8b92" "#c3e88d" "#e1acff" "#ffe585")

#######################################################
# Dzen2 utils
#######################################################

dzen2_draw_stacked_bar() {
    # Default values
    local width=100
    local height=4
    local max_value=100
    local values=()
    local fg_colors=("${DEFAULT_STACK_COLORS[@]}")
    local padding=1
    local bg="#CCCCCC"
    local draw_outline=""

    # Parse named arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -width)
                width="$2"
                shift 2
                ;;
            -height)
                height="$2"
                shift 2
                ;;
            -max_value)
                max_value="$2"
                shift 2
                ;;
            -values)
                IFS=',' read -r -a values <<< "$2"
                shift 2
                ;;
            -fg_colors)
                IFS=',' read -r -a fg_colors <<< "$2"
                shift 2
                ;;
            -padding)
                padding="$2"
                shift 2
                ;;
            -bg)
                bg="$2"
                shift 2
                ;;
            -draw_outline)
                draw_outline="yes"
                shift 1
                ;;
            *)
                echo "dzen2_draw_stacked_bar(): Unknown option: $1" 1>&2
                return 1
                ;;
        esac
    done

    local num_values=${#values[@]}
    local total_padding=$((padding * (num_values - 1)))
    local available_width=$((width - total_padding))

    local output="^ib(1)"

    local rendered_width=0
    if [[ -n "$draw_outline" ]]; then
        available_width=$((available_width - 1))
        rendered_width=$((rendered_width + 1))
        output="${output}^p(1,0)" # 1px left padding
    else
        output="${output}^fg($bg)^r(${width}x${height})^p(-${width},0)"
    fi

    for ((i = 0; i < num_values; i++)); do
        local value=${values[i]}
        local fg_color=${fg_colors[i]}
        local bar_width=$((value * available_width / max_value))

        if ((bar_width > 0)); then
            output="${output}^fg(${fg_color})^r(${bar_width}x${height}})^p(${padding},0)"
            rendered_width=$((rendered_width + bar_width + padding))
        fi
    done

    if [[ -n "$draw_outline" ]]; then
        rendered_width=$((rendered_width))
        # set X pos back of rendered width and render outline rect on top
        output="${output}^p(-${rendered_width},0)^fg($bg)^ro(${width}x${height})"
    else
        offset=$((available_width - rendered_width + 1))
        if ((offset > 0)); then
            output="${output}^fg($bg)^p($((offset > 0 ? offset : 0))x8)"
        fi
    fi

    printf "%s\n" "${output}^ib()"
}


dzen2_draw_h_stacked_bars() {
    # Default values
    local bar_width=4
    local height=$((CFG_HEIGHT - 2))
    local bottom_margin=1
    local max_value=100
    local stacks=1
    local values=()
    local fg_colors=("#ff8b92" "#c3e88d" "#e1acff" "#ffe585")
    local bar_padding=1
    local stack_padding=1
    local bg="#333"
    local border_fg="#777"

    # Parse named arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -bar_width)
                bar_width="$2"
                shift 2
                ;;
            -height)
                height="$2"
                shift 2
                ;;
            -bottom_margin)
                bottom_margin="$2"
                shift 2
                ;;
            -max_value)
                max_value="$2"
                shift 2
                ;;
            -stacks)
                stacks="$2"
                shift 2
                ;;
            -values)
                IFS=',' read -r -a values <<< "$2"
                shift 2
                ;;
            -fg_colors)
                IFS=',' read -r -a fg_colors <<< "$2"
                shift 2
                ;;
            -bar_padding)
                bar_padding="$2"
                shift 2
                ;;
            -stack_padding)
                stack_padding="$2"
                shift 2
                ;;
            -bg)
                bg="$2"
                shift 2
                ;;
            -border_fg)
                border_fg="$2"
                shift 2
                ;;
            *)
                echo "dzen2_draw_h_stacked_bars(): Unknown option: $1" 1>&2
                return 1
                ;;
        esac
    done

    local num_values=${#values[@]}
    local num_bars=$((num_values / stacks))
    local total_h_padding=$((bar_padding * (num_bars - 1)))

    local widget_width=$((num_bars * bar_width + total_h_padding + 2)) # 2 - borders
    local output="^p(_BOTTOM)^p(-3)^ib(1)^fg(${bg})^r(${widget_width}x${height}+0-$((height + bottom_margin)))" # bg rect
    output="${output}^fg(${border_fg})^ro(${widget_width}x${height}-${widget_width}+0)^p(-${widget_width})" # border

    # Iterate values. Step is count of stacks per bar
    for ((i = 0; i < num_values; i+=stacks)); do
        local non_zero_stacks=0
        for ((s = 0; s < stacks; s++)); do
            local total_v_padding=$((stack_padding * (stacks - 1)))
            local value=${values[$((i + s))]}
            local available_height=$((height - 2 - total_v_padding))
            local stack_height=$((value * available_height / max_value))
            if ((stack_height > 0)); then
                non_zero_stacks=$((non_zero_stacks + 1))
            fi
        done
        local total_v_padding=$((stack_padding * ((non_zero_stacks > 0 ? non_zero_stacks : 1) - 1)))

        for ((s = 0; s < stacks; s++)); do
            local value=${values[$((i + s))]}
            local fg_color=${fg_colors[s]} # bar color
            local available_height=$((height - 2 - total_v_padding))
            local stack_height=$((value * available_height / max_value))

            if ((s == 0)); then
                # For first bar, use 1px (border)
                local x_offset=$((i == 0 ? 1 : bar_padding))
                local y_offset=$((stack_height + bottom_margin + 1))
                output="${output}^p(_BOTTOM)^p(-3)^fg(${fg_color})^r(${bar_width}x${stack_height}+${x_offset}-${y_offset})"
            else
                output="${output}^fg(${fg_color})^r(${bar_width}x${stack_height}-${bar_width}-$((stack_height + stack_padding )))"
            fi

            if ((stack_height == 0)); then
                output="${output}^p(0;+${stack_padding})"
            fi
        done
    done
    printf "%s\n" "${output}^ib()^p()^p(1)"
}
