#!/usr/bin/env bash

CFG_HEIGHT="${CFG_HEIGHT:-24}"

if [ -z "${CFG_REPLACE_MAP+x}" ]; then
  declare -A CFG_REPLACE_MAP=()
fi

if [ -z "${CFG_DEFAULT_STACK_COLORS+x}" ]; then
  CFG_DEFAULT_STACK_COLORS=('#ff8b92' '#c3e88d' '#e1acff' '#ffe585')
fi

check_dependencies() {
    local missing_dependencies=()

    # Check for each dependency
    for dep in "$@"; do
        if ! type "$dep" &>/dev/null; then
            missing_dependencies+=("$dep")
        fi
    done

    # If there are missing dependencies, print them and exit
    if [ ${#missing_dependencies[@]} -ne 0 ]; then
        echo >&2 "Missing executables: ${missing_dependencies[@]}"
        exit 1
    fi
}

read_sleep() {
    # Usage: read_sleep 1
    #        read_sleep 0.2
    read -rt "$1" <> <(:) || :
}

build_sed_replace_command() {
    local sed_command=""
    for key in "${!CFG_REPLACE_MAP[@]}"; do
        local value="${CFG_REPLACE_MAP[$key]}"
        sed_command+="s/$key/$value/g;"
    done

    echo "$sed_command"
}

is_array() {
    local var_name=$1
    local var_decl
    var_decl=$(eval "declare -p $var_name" 2>/dev/null)
    [[ $var_decl =~ "declare -a" ]]
}

# Function to extract the value of a given parameter
extract_param_value() {
    local param_name="$1"
    shift
    local params=("$@")
    local param_value=""

    for (( i=0; i<${#params[@]}; i++ )); do
        if [[ "${params[i]}" == "$param_name" ]]; then
            # Assuming the next item is the value
            param_value="${params[i+1]}"
            break
        fi
    done

    echo "$param_value"
}

#######################################################
# Dzen2 utils
#######################################################

dzen2_draw_stacked_bar() {
    # Default values
    local width=100
    local height=4
    local max_value=100
    local values=()
    local fg_colors=("${DEFAULT_STACK_COLORS[@]}")
    local padding=1
    local bg="#CCCCCC"
    local draw_outline=""

    # Parse named arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -width)
                width="$2"
                shift 2
                ;;
            -height)
                height="$2"
                shift 2
                ;;
            -max_value)
                max_value="$2"
                shift 2
                ;;
            -values)
                IFS=',' read -r -a values <<< "$2"
                shift 2
                ;;
            -fg_colors)
                IFS=',' read -r -a fg_colors <<< "$2"
                shift 2
                ;;
            -padding)
                padding="$2"
                shift 2
                ;;
            -bg)
                bg="$2"
                shift 2
                ;;
            -draw_outline)
                draw_outline="yes"
                shift 1
                ;;
            *)
                echo "dzen2_draw_stacked_bar(): Unknown option: $1" 1>&2
                return 1
                ;;
        esac
    done

    local num_values=${#values[@]}
    local total_padding=$((padding * (num_values - 1)))
    local available_width=$((width - total_padding))

    local output="^ib(1)"

    local rendered_width=0
    if [[ -n "$draw_outline" ]]; then
        available_width=$((available_width - 1))
        rendered_width=$((rendered_width + 1))
        output="${output}^p(1,0)" # 1px left padding
    else
        output="${output}^fg($bg)^r(${width}x${height})^p(-${width},0)"
    fi

    for ((i = 0; i < num_values; i++)); do
        local value=${values[i]}
        local fg_color=${fg_colors[i]}
        local bar_width=$((value * available_width / max_value))

        if ((bar_width > 0)); then
            output="${output}^fg(${fg_color})^r(${bar_width}x${height}})^p(${padding},0)"
            rendered_width=$((rendered_width + bar_width + padding))
        fi
    done

    if [[ -n "$draw_outline" ]]; then
        rendered_width=$((rendered_width))
        # set X pos back of rendered width and render outline rect on top
        output="${output}^p(-${rendered_width},0)^fg($bg)^ro(${width}x${height})"
    else
        offset=$((available_width - rendered_width + 1))
        if ((offset > 0)); then
            output="${output}^fg($bg)^p($((offset > 0 ? offset : 0))x8)"
        fi
    fi

    printf "%s\n" "${output}^ib()"
}

dzen2_draw_h_stacked_bars() {
    # Default values
    local bar_width=4
    local height=$((CFG_HEIGHT - 2))
    local bottom_margin=1
    local max_value=100
    local stacks=1
    local values=()
    local fg_colors=("${CFG_DEFAULT_STACK_COLORS[@]}")
    local bar_padding=1
    local stack_padding=1
    local bg="#333"
    local border_fg="#777"

    # Parse named arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -bar_width)
                bar_width="$2"
                shift 2
                ;;
            -height)
                height="$2"
                shift 2
                ;;
            -bottom_margin)
                bottom_margin="$2"
                shift 2
                ;;
            -max_value)
                max_value="$2"
                shift 2
                ;;
            -stacks)
                stacks="$2"
                shift 2
                ;;
            -values)
                IFS=',' read -r -a values <<< "$2"
                shift 2
                ;;
            -fg_colors)
                IFS=',' read -r -a fg_colors <<< "$2"
                shift 2
                ;;
            -bar_padding)
                bar_padding="$2"
                shift 2
                ;;
            -stack_padding)
                stack_padding="$2"
                shift 2
                ;;
            -bg)
                bg="$2"
                shift 2
                ;;
            -border_fg)
                border_fg="$2"
                shift 2
                ;;
            *)
                echo "dzen2_draw_h_stacked_bars(): Unknown option: $1" 1>&2
                return 1
                ;;
        esac
    done

    local num_values=${#values[@]}
    local num_bars=$((num_values / stacks))
    local total_h_padding=$((bar_padding * (num_bars - 1)))

    local widget_width=$((num_bars * bar_width + total_h_padding + 2)) # 2 - borders
    local output="^p(_BOTTOM)^p(-3)^ib(1)^fg(${bg})^r(${widget_width}x${height}+0-$((height + bottom_margin)))" # bg rect
    output="${output}^fg(${border_fg})^ro(${widget_width}x${height}-${widget_width}+0)^p(-${widget_width})" # border

    # Iterate values. Step is count of stacks per bar
    for ((i = 0; i < num_values; i+=stacks)); do
        local non_zero_stacks=0
        for ((s = 0; s < stacks; s++)); do
            local total_v_padding=$((stack_padding * (stacks - 1)))
            local value=${values[$((i + s))]}
            local available_height=$((height - 2 - total_v_padding))
            local stack_height=$((value * available_height / max_value))
            if ((stack_height > 0)); then
                non_zero_stacks=$((non_zero_stacks + 1))
            fi
        done
        local total_v_padding=$((stack_padding * ((non_zero_stacks > 0 ? non_zero_stacks : 1) - 1)))

        for ((s = 0; s < stacks; s++)); do
            local value=${values[$((i + s))]}
            local fg_color=${fg_colors[s]} # bar color
            local available_height=$((height - 2 - total_v_padding))
            local stack_height=$((value * available_height / max_value))

            if ((s == 0)); then
                # For first bar, use 1px (border)
                local x_offset=$((i == 0 ? 1 : bar_padding))
                local y_offset=$((stack_height + bottom_margin + 1))
                output="${output}^p(_BOTTOM)^p(-3)^fg(${fg_color})^r(${bar_width}x${stack_height}+${x_offset}-${y_offset})"
            else
                output="${output}^fg(${fg_color})^r(${bar_width}x${stack_height}-${bar_width}-$((stack_height + stack_padding )))"
            fi

            if ((stack_height == 0)); then
                output="${output}^p(0;+${stack_padding})"
            fi
        done
    done
    printf "%s\n" "${output}^ib()^p()^p(1)"
}

dzen2_draw_flags() {
    local label=""      # no label
    local label_size=45 # size of label
    local label_highlight=0
    local color_on="#afa"
    local color_all_off="#777"
    local color_bg="#000"
    local color_fg="#fff"
    local name_size=50
    local y_padding=2
    local fn_main="" # will be rendered as ^fn()
    local fn_2rows="Terminus-8"
    local fn_2rows_y_offset=0
    local flag_align="_CENTER"
    local flag_x_padding=0

    # mandatory params
    local -n dictionary_short_names_ref=$1
    shift
    local -n dictionary_ref=$1
    shift
    local -n keys_to_render_ref=$1
    shift

    # override params
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -label) label="$2"; shift 2;;
            -label_size) label_size="$2"; shift 2;;
            -label_highlight) label_highlight="$2"; shift 2;;
            -color_on) color_on="$2"; shift 2;;
            -color_all_off) color_all_off="$2"; shift 2;;
            -color_bg) color_bg="$2"; shift 2;;
            -color_fg) color_fg="$2"; shift 2;;
            -name_size) name_size="$2"; shift 2;;
            -y_padding) y_padding="$2"; shift 2;;
            -fn_main) fn_main="$2"; shift 2;;
            -fn_2rows) fn_2rows="$2"; shift 2;;
            -fn_2rows_y_offset) fn_2rows_y_offset="$2"; shift 2;;
            -flag_align) flag_align="$2"; shift 2;;
            -flag_x_padding) flag_x_padding="$2"; shift 2;;
            *) echo "dzen2_draw_flags(): Unknown parameter: $1"; exit 1;;
        esac
    done

    local out="^ib(1)"
    local height=$((CFG_HEIGHT - 2 * y_padding))

    local has_on_value=0
    for key in "${keys_to_render_ref[@]}"; do
        if [[ "${dictionary_ref[$key]}" == "ON" ]]; then
            has_on_value=1
            break
        fi
    done

    # draw label if exist
    local setup_label_area=""
    local set_border_color="" # if at least one flag is ON, then set "ON" color as primary color
    if ((has_on_value == 1)); then
        if ((label_highlight == 1)); then
            setup_label_area="^p()^fg(${color_on})^r(${label_size}x${height})^fg(${color_bg})"
        else
            setup_label_area="^p()^fg(${color_on})^ro(${label_size}x${height}})"
        fi
        set_border_color="^fg(${color_on})"
    else
        if [[  -n "$label" ]]; then
            setup_label_area="^p()^fg(${color_all_off})^ro(${label_size}x${height})"
        fi
        set_border_color="^fg(${color_all_off})"
    fi
    if [[  -n "$label" ]]; then
        # centered label
        out+="${setup_label_area}^p(-${label_size})^ba(${label_size},_CENTER)${label}"
    fi

    # set 2 rows font
    out+="^fn($fn_2rows)"

    local index=0
    # draw flag state
    for key in "${keys_to_render_ref[@]}"; do
        local flag_name="${dictionary_short_names_ref[$key]}"
        if [[ -z "$flag_name" ]]; then
            flag_name="$key"
        fi

        local label_cmd="^p(-$((name_size - flag_x_padding));${fn_2rows_y_offset})^ba($((name_size - flag_x_padding)),${flag_align})${flag_name}"
        if (((index % 2) == 0)); then
            # draw in top
            out+="${set_border_color}^p(_TOP)^p(-3;${y_padding})"
            if [[ "${dictionary_ref[$key]}" == "ON" ]]; then
                out+="^r(${name_size}x$((height / 2 + 1)))^fg(${color_bg})$label_cmd"
            else
                out+="^ro(${name_size}x$((height / 2  +1)))$label_cmd"
            fi
        else
            # draw in bottom
            out+="${set_border_color}^p(_TOP)^p(-$((name_size + 2));${y_padding})"
            if [[ "${dictionary_ref[$key]}" == "ON" ]]; then
                out+="^r(${name_size}x$((height / 2))-0+$((height / 2)))^fg(${color_bg})$label_cmd"
            else
                out+="^ro(${name_size}x$((height / 2 ))-0+$((height / 2)))$label_cmd"
            fi
        fi
        index=$((index+1))
    done

    # reset state
    out+="^ib()^p()^fg(${color_fg})^bg(${color_bg})^fn($fn_main)"
    printf "%s\n" "$out"
}
